extern "C"{#include <assert.h>#include <errno.h>#include <stdbool.h>#include <stdlib.h>#include <stdio.h>#include <sys/sysctl.h>#include <string.h>#include <stdio.h>#include <unistd.h>#include <signal.h>}static intget_real_command_name(const int pid, char *cbuf, const int csize){	int mib[4];	size_t arguments_size = 8096;	char arguments[arguments_size];    char *filename = NULL;        *cbuf = 0;    arguments [0] = 0;	/*	 * A sysctl() is made to find out the full path that the command	 * was called with.	 */	mib[0] = CTL_KERN;	mib[1] = KERN_PROCARGS;	mib[2] = pid;	mib[3] = 0;	if (sysctl(mib, 3, arguments, &arguments_size, NULL, 0) >= 0) {        if (strlen (arguments) > 0) {            char *next = strtok(arguments, "/");            filename = next;            while (next != NULL) {                filename = next;                next = strtok(NULL, "/");            }            if (filename && (strlen (filename) < csize)) {                strcpy(cbuf, filename);            }        }    }    return (*cbuf > 0);}static bool MacIsAppRunning ( const char *appname, bool bKill ){    int                 err;    kinfo_proc *        result;    bool                done;    static const int    name[] = { CTL_KERN, KERN_PROC, KERN_PROC_ALL, 0 };    // Declaring name as const requires us to cast it when passing it to    // sysctl because the prototype doesn't include the const modifier.    size_t              length;    // We start by calling sysctl with result == NULL and length == 0.    // That will succeed, and set length to the appropriate length.    // We then allocate a buffer of that size and call sysctl again    // with that buffer.  If that succeeds, we're done.  If that fails    // with ENOMEM, we have to throw away our buffer and loop.  Note    // that the loop causes use to call sysctl with NULL again; this    // is necessary because the ENOMEM failure case sets length to    // the amount of data returned, not the amount of data that    // could have been returned.    result = NULL;    done = false;    do {        assert(result == NULL);        // Call sysctl with a NULL buffer.        length = 0;        err = sysctl( (int *) name, (sizeof(name) / sizeof(*name)) - 1,                      NULL, &length,                      NULL, 0);        if (err == -1)         {            err = errno;        }        // Allocate an appropriately sized buffer based on the results        // from the previous call.        if (err == 0)         {            result = (kinfo_proc *) malloc(length);            if (result == NULL)             {                err = ENOMEM;            }        }        // Call sysctl again with the new buffer.  If we get an ENOMEM        // error, toss away our buffer and start again.        if (err == 0)         {            err = sysctl( (int *) name, (sizeof(name) / sizeof(*name)) - 1,                          result, &length,                          NULL, 0);            if (err == -1)             {                err = errno;            }            if (err == 0)             {                done = true;            }             else if (err == ENOMEM)             {                assert(result != NULL);                free(result);                result = NULL;                err = 0;            }        }    } while (err == 0 && ! done);        //  scan the list looking for our app        int procCount = length / sizeof(kinfo_proc);        bool bRunning = false;    for (int i=0;i<procCount;i++)    {        char realCommand[4096];                get_real_command_name(result[i].kp_proc.p_pid, realCommand, sizeof(realCommand));                char *p_appname = result[i].kp_proc.p_comm;        bRunning = strcmp (realCommand, appname)==0 || strcmp (p_appname, appname)==0;                if ( bKill && bRunning )        {            printf ( "killing %s, pid %d\n", appname, result[i].kp_proc.p_pid );            kill ( result[i].kp_proc.p_pid, SIGKILL );            if (result != NULL)             {                free(result);                result = NULL;            }            return bRunning;        }    }        //  clean up    if (result != NULL)     {        free(result);        result = NULL;    }    return bRunning;}#define shortName2 "USBMenu"#define longName2  "/usr/bin/open \"/Applications/IntelliTools/IntelliKeys USB/Private/USBMenu.app\""#define PERIOD 1000000  //  one second////  This program checks for the existence of//  a certain program, and if it's missing, launches it.//int main (int argc, const char * argv[]) {    bool bRunning = FALSE;        //  kill helper watcher    bRunning = MacIsAppRunning ( "USBHelperWatcher", true );        //  kill helper    bRunning = MacIsAppRunning ( "USBMenu", true );        //  kill engine    bRunning = MacIsAppRunning ( "ikusb", true );        return 0;}
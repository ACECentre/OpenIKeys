{\rtf1\mac\ansicpg10000\cocoartf102{\fonttbl\f0\fswiss\fcharset77 Helvetica;\f1\fswiss\fcharset77 ArialMT;\f2\fmodern\fcharset77 CourierNewPSMT;\f3\froman\fcharset77 TimesNewRomanPSMT;\f4\fswiss\fcharset77 Arial-BoldMT;\f5\fnil\fcharset77 Monaco;\f6\fnil\fcharset77 Geneva;}{\colortbl;\red255\green255\blue255;\red0\green0\blue128;}\margl1440\margr1440\vieww14540\viewh11340\viewkind0\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\ql\qnatural\f0\fs24 \cf0 ID USB Command Protocol\01/20/03 ejm created based on Fred's emails.\\The Root folder contains a folder named Private which contains a folder called Channels.  The Channels folder has one folder for each component that will send text messages to other components in the system.  For now this includes two things.  First, the "Engine" controls the USB interface.  The "Control Panel" allows the user to change and save settings to the hardware.  These two components communicate to each other through their respective channel folders.  \\\pard\tx720\li720\fi-720\ql\qnatural\cf0 -	[Root]\\pard\tx1440\li1440\fi-720\ql\qnatural\cf0 -	Preferences.txt\\pard\tx1440\li1440\ql\qnatural\cf0 This is the preferences file for certain settings.  In particular, this contains the setting for "Group" and "Student" that indicates the current user.  "Group" is the name of the current group, which corresponds to a group folder name within the "Users: folder.  "Student" is the name of the current user, which corresponds to a user folder name within the current group folder.  If "Group" is "Guest", then "Student" is blank.\\pard\tx1440\li1440\fi-720\ql\qnatural\cf0 -	[Private]\\pard\tx2160\li2160\fi-720\ql\qnatural\cf0 -	[Channels]\\pard\tx2880\li2880\fi-720\ql\qnatural\cf0 -	[Control Panel]\\pard\li2880\ql\qnatural\cf0 This folder is the channel folder for communicating TO the IK USB control panel.  It is owned by the control panel.\\pard\tx3600\li3600\fi-720\ql\qnatural\cf0 -	Active.dat (only while the channel is active)\-	Claim.dat\-	Command.dat (only exists when a command to the channel is pending)\-	Response.dat (only exists when a response to a command is pending)\\pard\tx2880\li2880\fi-720\ql\qnatural\cf0 -	[Engine]\\pard\li2880\ql\qnatural\cf0 This folder is the channel folder for communicating TO the IK USB Engine.  It is owned by the engine.\\pard\tx3600\li3600\fi-720\ql\qnatural\cf0 -	Active.dat (only while the channel is active)\-	Claim.dat\-	Command.dat (only exists when a command to the channel is pending)\-	Response.dat (only exists when a response to a command is pending)\\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\ql\qnatural\cf0 \\The high level protocol works like this.  The sending component checks to see if the receiver's channel is active (the receiver is listening on the channel) by checking the receiver's "\f1\fs26 owner\f0\fs24 .dat" file.  If the file exists and it is opened exclusively by the receiver, then the channel is active.  If the channel is active, the sending component takes control of the channel by opening the receiver's "Claim.dat" file for exclusive writing.  If another component has already claimed the channel, then attempting to open claim.dat  will fail with an access violation, in which case the sender knows that the channel is busy.  If the channel is busy, the sender can choose to fail, or wait until Claim.dat becomes available, possibly timing-out.  Most transactions should complete within 1-2 seconds.  Once the sender takes control of the channel by opening claim.dat for exclusive writing, it will keep control of the channel by leaving claim.dat open until it receives a response, or chooses to time-out.\\After the sender claims the channel with claim.dat, the sender will create a new file in the receiver's channel folder named "Command.dat".  This file has the following format:\\\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\f2\fs26 \cf0 o\f3\fs20 \'ca\'ca\'ca\'ca\'ca\'ca\'ca \f1\fs26 command tag \'d0 4 bytes, binary; identifies the command to execute\f3\fs32 \\f2\fs26 o\f3\fs20 \'ca\'ca\'ca\'ca\'ca\'ca\'ca \f1\fs26 size of data \'d0 4 bytes, binary; number of bytes in the data block\f3\fs32 \\f2\fs26 o\f3\fs20 \'ca\'ca\'ca\'ca\'ca\'ca\'ca \f1\fs26 data block \'d0 command-specific format\\For commands that involve text, the data block will contain unicode text.\\The receiver will poll it's channel folder for command.dat, open it, read it, then delete it.  It will then process the command.  When it is done processing the command, it will create a file named "Response.dat" in it's channel folder, write the command response to it and close it. \\The response.dat file has a very similar format to command.dat, except that the command tab is a response code. So a response.dat file has this format:\\\f2 o\f3\fs20 \'ca\'ca\'ca\'ca\'ca\'ca\'ca \f1\fs26 response code \'d0 4 bytes, binary; identifies the response\f3\fs32 \\f2\fs26 o\f3\fs20 \'ca\'ca\'ca\'ca\'ca\'ca\'ca \f1\fs26 size of data \'d0 4 bytes, binary; number of bytes in the data block\f3\fs32 \\f2\fs26 o\f3\fs20 \'ca\'ca\'ca\'ca\'ca\'ca\'ca \f1\fs26 data block \'d0 response-specific format\\As with commands, if the data block contains a string, it will be in unicode16 format.\\After the sender writes command.dat, it waits for a file named "Response.dat" to be created in the receiver's channel folder.  This file is written by the receiver after it finishes processing the command.dat file.  The sender should open the response.dat file, read it's content, then erase the file.  It should then close the claim.dat file, thus releasing the channel for other components use.  This leaves the channel folder in exactly the same state as at the start of the transaction.  At this point, the sender is done with the transaction (possibly not happy, but certainly done.)\\\f4\b Opening a message channel:\\f1\b0 The owner of a channel (the receiver on the channel) must let other components know that it is actively processing messages on the channel.  This is so that senders are not constantly waiting for responses on inactive channels that will never show up.  The channel owner makes the channel active by creating a file named "owner.dat" in their channel folder, then opening it for exclusive write.  The file is kept open while the receiver listens on the channel.  When the receiver is ready to shut down, they close and delete the file.\\1. Create 'owner.dat' in the channel folder if it does not already exist.\2. Open 'owner.dat' for exclusive write and leave it open.\\\f4\b Closing a message channel:\\f1\b0 When the owner of the channel decides to stop processing commands, usually to shut down, the owner must indicate that the channel is no longer active.  It does this by closing the 'owner.dat' file and deleting it from the channel folder.\\1. Close 'owner.dat'\2. Delete 'owner.dat' from the channel folder.\\Note that sender's should check for both the existance of the file and whether the file is in use (Not just for existance).  This is because it is possible that a channel owner might crash and lose control of the channel.  In this case, the file will exist, but it will not be in use (unless the owner is in an infinite loop).\\\f4\b Sending a Command:\\f1\b0 \1. Determine if the receiver's channel is active.  If the file named "owner.dat" in the receiver's folder exists and if trying to open it for writing fails (because the receiver has it open), then the receiver is actively listening to their channel.  If they are not listening to the channel, then any message that is sent will not be responded to.\2. Wait for a file named "Claim.dat" in the receiver's channel folder to become available for writing.\3. When receiver's claim.dat file becomes available, open it for exclusive write.\4. Clean the channel by deleting any existing command.dat and/or response.dat.\5. Create a file named "Command.dat" in the receiver's channel folder, and write the command record to the file.  Then close the file.\6. Wait for a file named "Response.dat" to be created in the receiver's channel folder and become available for reading.  \7. Open the receiver's response.dat file, read it's contents, then erase the file.\8. Close the receiver's claim.dat file.\\\f4\b Receiving a Command:\\f1\b0 The owner of the channel (the receiver) will have to stay in a loop, looking for a command.dat file to appear in it's channel folder.  When it sees command.dat, it should open it, read it in, then erase it.  After processing the command within the command.dat file, the receiver should create a file named "Response.dat" in it's channel folder, and write the command specific response to the file, then close it.  After doing that, the transaction is complete from the receiver's point of view, so it goes back into it's loop looking for a command.dat file to be created.\\1. Poll for a file named "Command.dat" to be created in the channel folder.\2. When command.dat becomes available for reading, open it, read it's entire contents, then delete it.\3. Process the command (this is command specific)\4. Create a file named "Response.dat" in the channel folder.  Write the response record (command specific) to the file.  Close the file.\\Receivers need to response in a timely fashion, so that senders are not stuck waiting for a response.  If the receiver will take a long time to process the command, then it should respond quickly to the command by writing a response.dat that basically indicates that the command was received, then process the command.  In cases where processing may take a long time, but the sender still needs to know the outcome of the processing (not just that the processing has started), then the another command should be sent (this time form the component that is doing the processing to the component that asked for the processing), indicating the outcome of the processing.\\\f4\b Command/Response formats:\\f1\b0 \\f4\b Change the current user & read settings.txt\\f1\b0 \\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\cf0 \ul Command tag\ulnone  = 1014 (kQuerySetStudent)\\ul Data Block\ulnone  =\\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\f5\fs20 \cf0 \size of characters\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca \'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca1 byte\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca1 (for Ascii) or 2 (for Unicode16)\\number of chars in groupname\'ca\'ca        1 byte\\groupname\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'can bytes\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca n = number of chars * size\\number of chars in studentname\'ca\'ca\'ca\'ca\'ca\'ca\'ca 1 byte\\studentname\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'can bytes\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca n = number of chars * size\\\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\f1\fs26 \cf0 Response:\Response Code = -1014 (kRespondSetStudent)\Data block = empty\size of data block = 0\\\Receiver should change their current group and user strings, re-read the settings file for that user, use those settings as the current settings, then write the response. The sender should not have settings.txt open while it is waiting for a response.\\\f4\b Get USB Keyboard Array\\f1\b0 Ask the engine to return information about each connected USB keyboard.  The information includes the one record for each connected device.  Each device record includes the device's serial number,  it's on/off status and the other information specified in the response block (see below).  When in diagnostic mode, the x,y pairs represent coordinates on the keyboard pad surface that are being touched.\\Recipient = engine\Command Tag = 1051 ( kQueryUSBIntelliKeysArray )\Data block = empty\size of data block = 0\\Response:\Response Code = -1051 (kRespondUSBIntelliKeysArray)\Size of data block = variable; see table below\Data block =\f5\fs20 \ul \item name \'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca         size of item\\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\cf0 \ulnone \number of connected devices:\'ca\'ca\'ca \'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca   1 byte\\for each connected device\\{\    device index:\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca  1 byte\\    on(1) or off (0):\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca  \'ca\'ca\'ca\'ca\'ca\'ca1 byte\\    sensor array:\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca  \'ca\'ca\'ca\'ca9 bytes\\    current overlay level (1 to 15):\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca1 byte\\    is standard overlay present (0 or 1):\'ca\'ca\'ca  1 byte\\    length of current overlay name in chars:  1 byte\        (bytes = 2 * chars for unicode16)\\    current overlay name (unicode16 on PC):\'ca\'ca\'can bytes\\\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\cf2     length of serial number in chars:\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca1 byte\\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\cf0         (bytes = 2 * chars for unicode16)\\    \cf2 serial number string (unicode16 on PC):\'ca\'ca\'can bytes\\    switch 1 status (1 = on, 0 = off)         1 byte\cf0 \\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\cf2     switch 2 status (1 = on, 0 = off)         1 byte\\    number of x,y pairs                       1 byte\    for each pair:\        x value (0-23)                        1 byte\        y value (0-23)                        1 byte\cf0 \\}\\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\f1\fs26 \cf0 \\\f4\b Shutdown Control panel\\f1\b0 Tell the control panel to quit.\\Recipient = control panel\Command Tag = 1003 (	 kQueryShutdown )\Data block = empty\size of data block = 0\\Response:\Response Code = -1017 (kRespondNoError)\Data block = empty\size of data block = 0\\Receiver should finish what they are doing, close their channel, and quit the application.\\\f4\b Show Control panel\\f1\b0 Tell the control panel to Activate itself (bring it's window to the front) if it is not already.\\Recipient = control panel\Command Tag = 1002 (	 \f6\fs24 kQueryShowControlPanel\f1\fs26  )\Data block = empty\size of data block = 0\\Response:\Response Code = -1017 (kRespondNoError)\Data block = empty\size of data block = 0\\Receiver should show it's window and bring it to the front.\\\f4\b Keyboard was plugged in or unplugged.\\f1\b0 The engine tells other channels that a keyboard was unplugged or plugged in.  It does this by sending a fresh array of device data, much like the response to command #1021 (kQueryUSBIntelliKeysArray)\\Recipient = Control Panel\Command Tag = 1022 ( kQueryUSBIntelliKeysArrayChanged )\Data block = formatted the same as the response to command #1021 (kQueryUSBIntelliKeysArray)\size of data block = variable; see table for response to command #1021 (kQueryUSBIntelliKeysArray)\\Response:\Response Code = -1022 (kRespondUSBIntelliKeysArrayChanged)\Data block = empty\size of data block = 0\\\f4\b Reset Keyboard\\f1\b0 Tells the engine to reset the keyboard.\\Recipient = engine\Command Tag = 1020 (kQueryResetKeyboard)\Data block = empty\size of data block = 0\\Response:\Response Code = -1020 (kRespondResetKeyboard)\data block is empty\size of data block = 0\\\f4\b Get Software Version:\\f1\b0 Ask the engine which version of the software is running.\\Recipient = engine\Command Tag = 1024 (kQuerySoftwareVersion)\data block is empty\size of data block = 0\\Response:\Response Code = -1024 (kRespondSoftwareVersion)\data block = Unicode string containing software version string.\size of datablock = number of unicode characters in datablock (including null terminator) * 2\\\\f4\b Get Firmware Version:\\f1\b0 Ask the engine which version of the software is running.\\Recipient = engine\Command Tag = 1025 (kQueryFirmwareVersion)\data block is empty\size of data block = 0\\Response:\Response Code = -1025 (kRespondFirmwareVersion)\data block = Unicode string containing firmware version string.\size of datablock = number of unicode characters in datablock (including null terminator) * 2\\\\f4\b Start Diagnostic Mode\\f1\b0 Tell the engine to start diagnostic mode.  When in diagnostic mode, the engine will stop sending mouse and keyboard information to the operating systems, and just send keyboard info to the control panel.  This mode is turned on by the control panel when the troubleshooting tab is displayed.\\Recipient = engine\Command Tag = 1026 (kQueryStartDiagnosticMode)\data block = empty\size of data block = 0\\Response\Response Code = -1026 (kRespondStartDiagnosticMode)\data block = empty\size of data block = 0\\\f4\b Stop Diagnostic Mode\\f1\b0 Tell the engine to stop diagnostic mode and resume normal keyboard operation.\\Recipient = engine\Command Tag = 1027 (kQueryStopDiagnosticMode)\data block = empty\size of data block = 0\\Response\Response Code = -1027 (kRespondStopDiagnosticMode)\data block = empty\size of data block = 0\\\f4\b Last Sent Overlay Name:\\f1\b0 As the engine for the name of the last sent overlay:\\Recipient = engine\Command Tag = 1029 (kQueryLastSentOverlay)\data block is empty\size of data block is zero\\Response:\Response Code = -1029 (kRespondLastSentOverlay)\data block = unicode name of last sent overlay\size of data block = number of characters in name (including null terminator) * 2\\\f4\b Query Global Data\\f1\b0 \Recipient = engine\Command Tag = 1059 (\cf2 kQueryGlobalData)\data block is empty\size of data block is zero\\Response:\Response Code = 1059 (kResponseGlobalData)\Data Block =\\\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\f5\fs20 \cf2 \ul Item                                           size\\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\cf2 \ulnone length of software version string in chars:\'ca\'ca\'ca 1 byte\cf0 \  (bytes = 2 * chars for unicode16)\\\cf2 software version string:\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca   \'can chars\cf0 \  (Unicode16 string on PC)\\\cf2 length of firmware version string in chars:\'ca\'ca\'ca\'ca1 byte\cf0 \  (bytes = 2 * chars for unicode16)\\\cf2 firmware version string:\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca   \'ca\'ca\'ca\'ca\'ca\'can chars\cf0 \  (Unicode16 string on PC)\\\cf2 length of last sent overlay name in chars: \'ca\'ca\'ca\'ca1 byte\cf0 \  (bytes = 2 * chars for unicode16)\\\cf2 last sent overlay name:\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca\'ca   \'ca\'ca\'ca\'ca n chars\cf0 \  (Unicode16 string on PC)\\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\f1\fs26 \cf0 \\}